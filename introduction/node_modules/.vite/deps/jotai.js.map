{"version":3,"file":"jotai.js","names":["atom","isPromiseLike","INTERNAL_buildStoreRev2","atom"],"sources":["../../jotai/esm/vanilla/internals.mjs","../../jotai/esm/vanilla.mjs","../../jotai/esm/react.mjs"],"sourcesContent":["function hasInitialValue(atom) {\n  return \"init\" in atom;\n}\nfunction isActuallyWritableAtom(atom) {\n  return !!atom.write;\n}\nfunction isAtomStateInitialized(atomState) {\n  return \"v\" in atomState || \"e\" in atomState;\n}\nfunction returnAtomValue(atomState) {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n}\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\nfunction isPendingPromise(value) {\n  var _a;\n  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\n}\nfunction abortPromise(promise) {\n  const promiseState = promiseStateMap.get(promise);\n  if (promiseState == null ? void 0 : promiseState[0]) {\n    promiseState[0] = false;\n    promiseState[1].forEach((fn) => fn());\n  }\n}\nfunction registerAbortHandler(promise, abortHandler) {\n  let promiseState = promiseStateMap.get(promise);\n  if (!promiseState) {\n    promiseState = [true, /* @__PURE__ */ new Set()];\n    promiseStateMap.set(promise, promiseState);\n    const settle = () => {\n      promiseState[0] = false;\n    };\n    promise.then(settle, settle);\n  }\n  promiseState[1].add(abortHandler);\n}\nfunction isPromiseLike(p) {\n  return typeof (p == null ? void 0 : p.then) === \"function\";\n}\nfunction addPendingPromiseToDependency(atom, promise, dependencyAtomState) {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    const cleanup = () => dependencyAtomState.p.delete(atom);\n    promise.then(cleanup, cleanup);\n  }\n}\nfunction getMountedOrPendingDependents(atom, atomState, mountedMap) {\n  var _a;\n  const dependents = /* @__PURE__ */ new Set();\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\n    if (mountedMap.has(a)) {\n      dependents.add(a);\n    }\n  }\n  for (const atomWithPendingPromise of atomState.p) {\n    dependents.add(atomWithPendingPromise);\n  }\n  return dependents;\n}\nconst createStoreHook = () => {\n  const callbacks = /* @__PURE__ */ new Set();\n  const notify = () => callbacks.forEach((fn) => fn());\n  notify.add = (fn) => {\n    callbacks.add(fn);\n    return () => callbacks.delete(fn);\n  };\n  return notify;\n};\nconst createStoreHookForAtoms = () => {\n  const all = {};\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const notify = (atom) => {\n    var _a, _b;\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\n  };\n  notify.add = (atom, fn) => {\n    const key = atom || all;\n    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);\n    fns.add(fn);\n    return () => {\n      fns == null ? void 0 : fns.delete(fn);\n      if (!fns.size) {\n        callbacks.delete(key);\n      }\n    };\n  };\n  return notify;\n};\nfunction initializeStoreHooks(storeHooks) {\n  storeHooks.r || (storeHooks.r = createStoreHookForAtoms());\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n  storeHooks.f || (storeHooks.f = createStoreHook());\n  return storeHooks;\n}\nconst atomRead = (_store, atom, ...params) => atom.read(...params);\nconst atomWrite = (_store, atom, ...params) => atom.write(...params);\nconst atomOnInit = (store, atom) => {\n  var _a;\n  return (_a = atom.unstable_onInit) == null ? void 0 : _a.call(atom, store);\n};\nconst atomOnMount = (_store, atom, setAtom) => {\n  var _a;\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n};\nconst ensureAtomState = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const atomStateMap = buildingBlocks[0];\n  const atomOnInit2 = buildingBlocks[9];\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\n    throw new Error(\"Atom is undefined or null\");\n  }\n  let atomState = atomStateMap.get(atom);\n  if (!atomState) {\n    atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n    atomStateMap.set(atom, atomState);\n    atomOnInit2 == null ? void 0 : atomOnInit2(store, atom);\n  }\n  return atomState;\n};\nconst flushCallbacks = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const mountCallbacks = buildingBlocks[4];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const errors = [];\n  const call = (fn) => {\n    try {\n      fn();\n    } catch (e) {\n      errors.push(e);\n    }\n  };\n  do {\n    if (storeHooks.f) {\n      call(storeHooks.f);\n    }\n    const callbacks = /* @__PURE__ */ new Set();\n    const add = callbacks.add.bind(callbacks);\n    changedAtoms.forEach((atom) => {\n      var _a;\n      return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n    });\n    changedAtoms.clear();\n    unmountCallbacks.forEach(add);\n    unmountCallbacks.clear();\n    mountCallbacks.forEach(add);\n    mountCallbacks.clear();\n    callbacks.forEach(call);\n    if (changedAtoms.size) {\n      recomputeInvalidatedAtoms2(store);\n    }\n  } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n  if (errors.length) {\n    throw new AggregateError(errors);\n  }\n};\nconst recomputeInvalidatedAtoms = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const ensureAtomState2 = buildingBlocks[11];\n  const readAtomState2 = buildingBlocks[14];\n  const mountDependencies2 = buildingBlocks[17];\n  const topSortedReversed = [];\n  const visiting = /* @__PURE__ */ new WeakSet();\n  const visited = /* @__PURE__ */ new WeakSet();\n  const stack = Array.from(changedAtoms);\n  while (stack.length) {\n    const a = stack[stack.length - 1];\n    const aState = ensureAtomState2(store, a);\n    if (visited.has(a)) {\n      stack.pop();\n      continue;\n    }\n    if (visiting.has(a)) {\n      if (invalidatedAtoms.get(a) === aState.n) {\n        topSortedReversed.push([a, aState]);\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n        throw new Error(\"[Bug] invalidated atom exists\");\n      }\n      visited.add(a);\n      stack.pop();\n      continue;\n    }\n    visiting.add(a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      if (!visiting.has(d)) {\n        stack.push(d);\n      }\n    }\n  }\n  for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n    const [a, aState] = topSortedReversed[i];\n    let hasChangedDeps = false;\n    for (const dep of aState.d.keys()) {\n      if (dep !== a && changedAtoms.has(dep)) {\n        hasChangedDeps = true;\n        break;\n      }\n    }\n    if (hasChangedDeps) {\n      readAtomState2(store, a);\n      mountDependencies2(store, a);\n    }\n    invalidatedAtoms.delete(a);\n  }\n};\nconst readAtomState = (store, atom) => {\n  var _a, _b;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomRead2 = buildingBlocks[7];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const mountDependencies2 = buildingBlocks[17];\n  const atomState = ensureAtomState2(store, atom);\n  if (isAtomStateInitialized(atomState)) {\n    if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n      return atomState;\n    }\n    if (Array.from(atomState.d).every(\n      ([a, n]) => (\n        // Recursively, read the atom state of the dependency, and\n        // check if the atom epoch number is unchanged\n        readAtomState2(store, a).n === n\n      )\n    )) {\n      return atomState;\n    }\n  }\n  atomState.d.clear();\n  let isSync = true;\n  function mountDependenciesIfAsync() {\n    if (mountedMap.has(atom)) {\n      mountDependencies2(store, atom);\n      recomputeInvalidatedAtoms2(store);\n      flushCallbacks2(store);\n    }\n  }\n  function getter(a) {\n    var _a2;\n    if (a === atom) {\n      const aState2 = ensureAtomState2(store, a);\n      if (!isAtomStateInitialized(aState2)) {\n        if (hasInitialValue(a)) {\n          setAtomStateValueOrPromise(store, a, a.init);\n        } else {\n          throw new Error(\"no atom init\");\n        }\n      }\n      return returnAtomValue(aState2);\n    }\n    const aState = readAtomState2(store, a);\n    try {\n      return returnAtomValue(aState);\n    } finally {\n      atomState.d.set(a, aState.n);\n      if (isPendingPromise(atomState.v)) {\n        addPendingPromiseToDependency(atom, atomState.v, aState);\n      }\n      (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n      if (!isSync) {\n        mountDependenciesIfAsync();\n      }\n    }\n  }\n  let controller;\n  let setSelf;\n  const options = {\n    get signal() {\n      if (!controller) {\n        controller = new AbortController();\n      }\n      return controller.signal;\n    },\n    get setSelf() {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n        console.warn(\"setSelf function cannot be used with read-only atom\");\n      }\n      if (!setSelf && isActuallyWritableAtom(atom)) {\n        setSelf = (...args) => {\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n            console.warn(\"setSelf function cannot be called in sync\");\n          }\n          if (!isSync) {\n            try {\n              return writeAtomState2(store, atom, ...args);\n            } finally {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n      }\n      return setSelf;\n    }\n  };\n  const prevEpochNumber = atomState.n;\n  try {\n    const valueOrPromise = atomRead2(store, atom, getter, options);\n    setAtomStateValueOrPromise(store, atom, valueOrPromise);\n    if (isPromiseLike(valueOrPromise)) {\n      registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n      valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);\n    }\n    (_a = storeHooks.r) == null ? void 0 : _a.call(storeHooks, atom);\n    return atomState;\n  } catch (error) {\n    delete atomState.v;\n    atomState.e = error;\n    ++atomState.n;\n    return atomState;\n  } finally {\n    isSync = false;\n    if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n      invalidatedAtoms.set(atom, atomState.n);\n      changedAtoms.add(atom);\n      (_b = storeHooks.c) == null ? void 0 : _b.call(storeHooks, atom);\n    }\n  }\n};\nconst invalidateDependents = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const ensureAtomState2 = buildingBlocks[11];\n  const stack = [atom];\n  while (stack.length) {\n    const a = stack.pop();\n    const aState = ensureAtomState2(store, a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      const dState = ensureAtomState2(store, d);\n      invalidatedAtoms.set(d, dState.n);\n      stack.push(d);\n    }\n  }\n};\nconst writeAtomState = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomWrite2 = buildingBlocks[8];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountDependencies2 = buildingBlocks[17];\n  let isSync = true;\n  const getter = (a) => returnAtomValue(readAtomState2(store, a));\n  const setter = (a, ...args2) => {\n    var _a;\n    const aState = ensureAtomState2(store, a);\n    try {\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevEpochNumber = aState.n;\n        const v = args2[0];\n        setAtomStateValueOrPromise(store, a, v);\n        mountDependencies2(store, a);\n        if (prevEpochNumber !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n        return void 0;\n      } else {\n        return writeAtomState(store, a, ...args2);\n      }\n    } finally {\n      if (!isSync) {\n        recomputeInvalidatedAtoms2(store);\n        flushCallbacks2(store);\n      }\n    }\n  };\n  try {\n    return atomWrite2(store, atom, getter, setter, ...args);\n  } finally {\n    isSync = false;\n  }\n};\nconst mountDependencies = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  const mounted = mountedMap.get(atom);\n  if (mounted && !isPendingPromise(atomState.v)) {\n    for (const [a, n] of atomState.d) {\n      if (!mounted.d.has(a)) {\n        const aState = ensureAtomState2(store, a);\n        const aMounted = mountAtom2(store, a);\n        aMounted.t.add(atom);\n        mounted.d.add(a);\n        if (n !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n      }\n    }\n    for (const a of mounted.d || []) {\n      if (!atomState.d.has(a)) {\n        mounted.d.delete(a);\n        const aMounted = unmountAtom2(store, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n    }\n  }\n};\nconst mountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const mountCallbacks = buildingBlocks[4];\n  const storeHooks = buildingBlocks[6];\n  const atomOnMount2 = buildingBlocks[10];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (!mounted) {\n    readAtomState2(store, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = mountAtom(store, a);\n      aMounted.t.add(atom);\n    }\n    mounted = {\n      l: /* @__PURE__ */ new Set(),\n      d: new Set(atomState.d.keys()),\n      t: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n    if (isActuallyWritableAtom(atom)) {\n      const processOnMount = () => {\n        let isSync = true;\n        const setAtom = (...args) => {\n          try {\n            return writeAtomState2(store, atom, ...args);\n          } finally {\n            if (!isSync) {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n        try {\n          const onUnmount = atomOnMount2(store, atom, setAtom);\n          if (onUnmount) {\n            mounted.u = () => {\n              isSync = true;\n              try {\n                onUnmount();\n              } finally {\n                isSync = false;\n              }\n            };\n          }\n        } finally {\n          isSync = false;\n        }\n      };\n      mountCallbacks.add(processOnMount);\n    }\n  }\n  return mounted;\n};\nconst unmountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {\n    var _a2;\n    return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom);\n  })) {\n    if (mounted.u) {\n      unmountCallbacks.add(mounted.u);\n    }\n    mounted = void 0;\n    mountedMap.delete(atom);\n    (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = unmountAtom2(store, a);\n      aMounted == null ? void 0 : aMounted.t.delete(atom);\n    }\n    return void 0;\n  }\n  return mounted;\n};\nconst setAtomStateValueOrPromise = (store, atom, valueOrPromise) => {\n  const ensureAtomState2 = getInternalBuildingBlocks(store)[11];\n  const atomState = ensureAtomState2(store, atom);\n  const hasPrevValue = \"v\" in atomState;\n  const prevValue = atomState.v;\n  if (isPromiseLike(valueOrPromise)) {\n    for (const a of atomState.d.keys()) {\n      addPendingPromiseToDependency(\n        atom,\n        valueOrPromise,\n        ensureAtomState2(store, a)\n      );\n    }\n  }\n  atomState.v = valueOrPromise;\n  delete atomState.e;\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n    ++atomState.n;\n    if (isPromiseLike(prevValue)) {\n      abortPromise(prevValue);\n    }\n  }\n};\nconst storeGet = (store, atom) => {\n  const readAtomState2 = getInternalBuildingBlocks(store)[14];\n  return returnAtomValue(readAtomState2(store, atom));\n};\nconst storeSet = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const writeAtomState2 = buildingBlocks[16];\n  try {\n    return writeAtomState2(store, atom, ...args);\n  } finally {\n    recomputeInvalidatedAtoms2(store);\n    flushCallbacks2(store);\n  }\n};\nconst storeSub = (store, atom, listener) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const mounted = mountAtom2(store, atom);\n  const listeners = mounted.l;\n  listeners.add(listener);\n  flushCallbacks2(store);\n  return () => {\n    listeners.delete(listener);\n    unmountAtom2(store, atom);\n    flushCallbacks2(store);\n  };\n};\nconst buildingBlockMap = /* @__PURE__ */ new WeakMap();\nconst getInternalBuildingBlocks = (store) => {\n  const buildingBlocks = buildingBlockMap.get(store);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !buildingBlocks) {\n    throw new Error(\n      \"Store must be created by buildStore to read its building blocks\"\n    );\n  }\n  return buildingBlocks;\n};\nfunction getBuildingBlocks(store) {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const enhanceBuildingBlocks = buildingBlocks[24];\n  if (enhanceBuildingBlocks) {\n    return enhanceBuildingBlocks(buildingBlocks);\n  }\n  return buildingBlocks;\n}\nfunction buildStore(...buildArgs) {\n  const store = {\n    get(atom) {\n      const storeGet2 = getInternalBuildingBlocks(store)[21];\n      return storeGet2(store, atom);\n    },\n    set(atom, ...args) {\n      const storeSet2 = getInternalBuildingBlocks(store)[22];\n      return storeSet2(store, atom, ...args);\n    },\n    sub(atom, listener) {\n      const storeSub2 = getInternalBuildingBlocks(store)[23];\n      return storeSub2(store, atom, listener);\n    }\n  };\n  const buildingBlocks = [\n    // store state\n    /* @__PURE__ */ new WeakMap(),\n    // atomStateMap\n    /* @__PURE__ */ new WeakMap(),\n    // mountedMap\n    /* @__PURE__ */ new WeakMap(),\n    // invalidatedAtoms\n    /* @__PURE__ */ new Set(),\n    // changedAtoms\n    /* @__PURE__ */ new Set(),\n    // mountCallbacks\n    /* @__PURE__ */ new Set(),\n    // unmountCallbacks\n    {},\n    // storeHooks\n    // atom interceptors\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount,\n    // building-block functions\n    ensureAtomState,\n    flushCallbacks,\n    recomputeInvalidatedAtoms,\n    readAtomState,\n    invalidateDependents,\n    writeAtomState,\n    mountDependencies,\n    mountAtom,\n    unmountAtom,\n    setAtomStateValueOrPromise,\n    storeGet,\n    storeSet,\n    storeSub,\n    void 0\n  ].map((fn, i) => buildArgs[i] || fn);\n  buildingBlockMap.set(store, Object.freeze(buildingBlocks));\n  return store;\n}\n\nexport { abortPromise as INTERNAL_abortPromise, addPendingPromiseToDependency as INTERNAL_addPendingPromiseToDependency, buildStore as INTERNAL_buildStoreRev2, getBuildingBlocks as INTERNAL_getBuildingBlocksRev2, getMountedOrPendingDependents as INTERNAL_getMountedOrPendingDependents, hasInitialValue as INTERNAL_hasInitialValue, initializeStoreHooks as INTERNAL_initializeStoreHooksRev2, isActuallyWritableAtom as INTERNAL_isActuallyWritableAtom, isAtomStateInitialized as INTERNAL_isAtomStateInitialized, isPendingPromise as INTERNAL_isPendingPromise, isPromiseLike as INTERNAL_isPromiseLike, promiseStateMap as INTERNAL_promiseStateMap, registerAbortHandler as INTERNAL_registerAbortHandler, returnAtomValue as INTERNAL_returnAtomValue };\n","import { INTERNAL_buildStoreRev2 } from 'jotai/vanilla/internals';\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nlet overiddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n  overiddenCreateStore = fn(overiddenCreateStore);\n}\nfunction createStore() {\n  if (overiddenCreateStore) {\n    return overiddenCreateStore();\n  }\n  return INTERNAL_buildStoreRev2();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n}\n\nexport { INTERNAL_overrideCreateStore, atom, createStore, getDefaultStore };\n","'use client';\nimport React, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nimport { INTERNAL_registerAbortHandler } from 'jotai/vanilla/internals';\n\nconst StoreContext = createContext(\n  void 0\n);\nfunction useStore(options) {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n}\nfunction Provider({\n  children,\n  store\n}) {\n  const storeRef = useRef(void 0);\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise) => {\n  if (!promise.status) {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n  }\n};\nconst use = React.use || // A shim for older React versions\n((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseStatus(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, getValue) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const onAbort = () => {\n        try {\n          const nextValue = getValue();\n          if (isPromiseLike(nextValue)) {\n            continuablePromiseMap.set(nextValue, continuablePromise);\n            curr = nextValue;\n            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n            INTERNAL_registerAbortHandler(nextValue, onAbort);\n          } else {\n            resolve(nextValue);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      INTERNAL_registerAbortHandler(promise, onAbort);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const { delay, unstable_promiseStatus: promiseStatus = !React.use } = options || {};\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (promiseStatus) {\n        try {\n          const value2 = store.get(atom);\n          if (isPromiseLike(value2)) {\n            attachPromiseStatus(\n              createContinuablePromise(value2, () => store.get(atom))\n            );\n          }\n        } catch (e) {\n        }\n      }\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay, promiseStatus]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value, () => store.get(atom));\n    if (promiseStatus) {\n      attachPromiseStatus(promise);\n    }\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],"mappings":"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"}